From 543779f1858e86e054573f84ba6919a4c3454cfd Mon Sep 17 00:00:00 2001
From: George Fu <nailao_5918@163.com>
Date: Wed, 23 Jun 2021 14:13:06 +0800
Subject: [PATCH 15/15] Add STM32F446 variants

---
 .../variants/STM32F446/PeripheralPins.c       | 245 +++++++++++
 .../STM32F4/variants/STM32F446/PinNamesVar.h  |  25 ++
 .../variants/STM32F446/hal_conf_extra.h       |  53 +++
 .../STM32F4/variants/STM32F446/ldscript.ld    | 185 +++++++++
 .../STM32F4/variants/STM32F446/variant.cpp    | 209 ++++++++++
 .../src/STM32F4/variants/STM32F446/variant.h  | 134 ++++++
 .../STM32F4/variants/STM32F446_b/.DS_Store    | Bin 0 -> 6148 bytes
 .../variants/STM32F446_b/PeripheralPins.c     | 387 ++++++++++++++++++
 .../variants/STM32F446_b/PinNamesVar.h        |  25 ++
 .../variants/STM32F446_b/hal_conf_extra.h     |  53 +++
 .../STM32F4/variants/STM32F446_b/ldscript.ld  | 184 +++++++++
 .../STM32F4/variants/STM32F446_b/variant.cpp  | 278 +++++++++++++
 .../STM32F4/variants/STM32F446_b/variant.h    | 325 +++++++++++++++
 13 files changed, 2103 insertions(+)
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446/PeripheralPins.c
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446/PinNamesVar.h
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446/hal_conf_extra.h
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446/ldscript.ld
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446/variant.cpp
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446/variant.h
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/.DS_Store
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/PeripheralPins.c
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/PinNamesVar.h
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/hal_conf_extra.h
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/ldscript.ld
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/variant.cpp
 create mode 100644 CoreN2G/src/STM32F4/variants/STM32F446_b/variant.h

diff --git a/CoreN2G/src/STM32F4/variants/STM32F446/PeripheralPins.c b/CoreN2G/src/STM32F4/variants/STM32F446/PeripheralPins.c
new file mode 100644
index 0000000..aaa971b
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446/PeripheralPins.c
@@ -0,0 +1,245 @@
+/*
+ *******************************************************************************
+ * Copyright (c) 2016, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ */
+#include <PeripheralPins.h>
+
+// =====
+// Note: Commented lines are alternative possibilities which are not used per default.
+//       If you change them, you will have to know what you do
+// =====
+
+
+//*** ADC ***
+
+#ifdef HAL_ADC_MODULE_ENABLED
+const PinMap PinMap_ADC[] = {
+  {PA_0,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 0, 0)}, // ADC1_IN0      E0_DIR
+  {PA_1,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC1_IN1      BLTOUCH_2
+  {PA_2,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC1_IN2      BLTOUCH_4
+  {PA_3,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC1_IN3      E1_EN
+  {PA_4,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC1_IN4      TF_SS
+  {PA_5,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC1_IN5      TF_SCLK
+  {PA_6,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 6, 0)}, // ADC1_IN6      TF_MISO
+  {PA_7,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 7, 0)}, // ADC1_IN7      LED
+  {PB_0,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 8, 0)}, // ADC1_IN8      HEATER2
+  {PB_1,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 9, 0)}, // ADC1_IN9      HEATER0
+  {PC_0,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC1_IN10    Z_EN      BED_T
+  {PC_1,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC1_IN11    EXP_14    T0
+  {PC_2,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC1_IN12    Z_DIR     T1  
+  {PC_3,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 13, 0)}, // ADC1_IN13    E0_EN     T2
+  {PC_4,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC1_IN14    EXP_8
+  {PC_5,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC1_IN15    EXP_7
+  {NC,    NP,    0}
+};
+#endif
+
+//*** DAC ***
+
+#ifdef HAL_DAC_MODULE_ENABLED
+const PinMap PinMap_DAC[] = {
+  {PA_4,  DAC1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // DAC_OUT1
+  {PA_5,  DAC1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // DAC_OUT2
+  {NC,    NP,    0}
+};
+#endif
+
+//*** I2C ***
+
+#ifdef HAL_I2C_MODULE_ENABLED
+const PinMap PinMap_I2C_SDA[] = {
+   {PB_7,  I2C1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+   {PC_9,  I2C3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)},
+   {PC_12, I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_I2C_MODULE_ENABLED
+const PinMap PinMap_I2C_SCL[] = {
+   {PA_8,  I2C3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)},
+   {PB_6,  I2C1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+   {PB_10, I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+  {NC,    NP,    0}
+};
+#endif
+
+//*** PWM ***
+
+#ifdef HAL_TIM_MODULE_ENABLED
+const PinMap PinMap_PWM[] = {
+  {PA_0,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)},  // TIM2_CH1
+   {PA_1,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 2, 0)},  // TIM2_CH2
+   {PA_2,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 3, 0)},  // TIM2_CH3 - STLink Tx
+   {PA_3,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 4, 0)},  // TIM2_CH4 - STLink Rx
+   {PA_5,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)},  // TIM8_CH1N
+  {PA_6,  TIM13,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM13, 1, 0)},  // TIM13_CH1
+  {PA_7,  TIM14,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM14, 1, 0)},  // TIM14_CH1
+  {PA_9,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 0)},  // TIM1_CH2
+  {PA_10, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 0)},  // TIM1_CH3
+  {PA_15, TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)},  // TIM2_CH1
+   {PB_0,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 3, 0)},  // TIM3_CH3
+   {PB_1,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 4, 0)},  // TIM3_CH4
+  {PB_3,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 2, 0)},  // E0 Heater, TIM2_CH2
+  {PB_4,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)},  // E1 Heater, TIM3_CH1
+  {PB_5,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)},  // LED G, TIM3_CH2
+  {PB_6,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 1, 0)},  // LED R, TIM4_CH1
+  {PB_7,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 2, 0)},  // LED B, TIM4_CH2
+   {PB_8,  TIM10,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM10, 1, 0)},  // TIM10_CH1
+  {PB_8,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 3, 0)},  // TIM4_CH3
+  {PB_9,  TIM11,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM11, 1, 0)},  // TIM11_CH1
+  {PB_10, TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 3, 0)},  // TIM2_CH3
+  {PB_13, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)},  // TIM1_CH1N
+  {PB_14, TIM12,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM12, 1, 0)},  // TIM12_CH1
+   {PB_15, TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)},  // TIM8_CH3N
+   {PC_6,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 0)},  // TIM8_CH1
+   {PC_7,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)},  // TIM3_CH2
+   {PC_8,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 0)},  // TIM8_CH3
+  {PC_9,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 4, 0)},  // TIM8_CH4
+  {NC,    NP,    0}
+};
+#endif
+
+//*** SERIAL ***
+
+#ifdef HAL_UART_MODULE_ENABLED
+const PinMap PinMap_UART_TX[] = {
+  {PA_9,  USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PD_8,  USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_6,  USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  {PB_6,  USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PA_2,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {PD_5,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {PB_10, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_10, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PA_0,  UART4,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+  {PC_12, UART5,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)},
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_UART_RX[] = {
+  {PA_10, USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PD_9,  USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_7,  USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  {PA_1,  UART4,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+  {PA_3,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {PB_7,  USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PC_11, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PD_2,  UART5,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)},
+  {PD_6,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_UART_RTS[] = {
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_UART_CTS[] = {
+  {NC,    NP,    0}
+};
+#endif
+
+//*** SPI ***
+
+#ifdef HAL_SPI_MODULE_ENABLED
+const PinMap PinMap_SPI_MOSI[] = {
+  {PA_7,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_15, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_12, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_SPI_MODULE_ENABLED
+const PinMap PinMap_SPI_MISO[] = {
+  {PA_6,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_14, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_11, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_SPI_MODULE_ENABLED
+const PinMap PinMap_SPI_SCLK[] = {
+  {PA_5,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_13, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_10, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_SPI_MODULE_ENABLED
+const PinMap PinMap_SPI_SSEL[] = {
+  {PA_4,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_12, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {NC,    NP,    0}
+};
+#endif
+
+//*** CAN ***
+
+#ifdef HAL_CAN_MODULE_ENABLED
+const PinMap PinMap_CAN_RD[] = {
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_CAN_MODULE_ENABLED
+const PinMap PinMap_CAN_TD[] = {
+  {NC,    NP,    0}
+};
+#endif
+
+//*** USB ***
+
+#ifdef HAL_PCD_MODULE_ENABLED
+const PinMap PinMap_USB_OTG_FS[] = {
+  {PA_11, USB_OTG_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_FS)}, // USB_OTG_FS_DM
+  {PA_12, USB_OTG_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_FS)}, // USB_OTG_FS_DP
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_PCD_MODULE_ENABLED
+const PinMap PinMap_USB_OTG_HS[] = {
+  {NC,    NP,    0}
+};
+#endif
+
+
+#ifdef HAL_SD_MODULE_ENABLED
+WEAK const PinMap PinMap_SD[] = {
+  {PC_8,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D0
+  {PC_9,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D1
+  {PC_10, SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D2
+  {PC_11, SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D3
+  {PC_12, SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF12_SDIO)}, // SDIO_CK
+  {PD_2,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF12_SDIO)}, // SDIO_CMD
+  {NC,    NP,    0}
+};
+#endif
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446/PinNamesVar.h b/CoreN2G/src/STM32F4/variants/STM32F446/PinNamesVar.h
new file mode 100644
index 0000000..c6e6b5c
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446/PinNamesVar.h
@@ -0,0 +1,25 @@
+/* USB */
+#ifdef USBCON
+#define USB_OTG_FS_SOF       PA_8
+#define USB_OTG_FS_VBUS      PA_9
+#define USB_OTG_FS_ID        PA_10
+#define USB_OTG_FS_DM        PA_11
+#define USB_OTG_FS_DP        PA_12
+#define USB_OTG_HS_ULPI_D0   PA_3
+#define USB_OTG_HS_SOF       PA_4
+#define USB_OTG_HS_ULPI_CK   PA_5
+#define USB_OTG_HS_ULPI_D1   PB_0
+#define USB_OTG_HS_ULPI_D2   PB_1
+#define USB_OTG_HS_ULPI_D7   PB_5
+#define USB_OTG_HS_ULPI_D3   PB_10
+#define USB_OTG_HS_ULPI_D4   PB_2
+#define USB_OTG_HS_ID        PB_12
+#define USB_OTG_HS_ULPI_D5   PB_12
+#define USB_OTG_HS_ULPI_D6   PB_13
+#define USB_OTG_HS_VBUS      PB_13
+#define USB_OTG_HS_DM        PB_14
+#define USB_OTG_HS_DP        PB_15
+#define USB_OTG_HS_ULPI_STP  PC_0
+#define USB_OTG_HS_ULPI_DIR  PC_2
+#define USB_OTG_HS_ULPI_NXT  PC_3
+#endif
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446/hal_conf_extra.h b/CoreN2G/src/STM32F4/variants/STM32F446/hal_conf_extra.h
new file mode 100644
index 0000000..c6669f2
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446/hal_conf_extra.h
@@ -0,0 +1,53 @@
+#pragma once
+
+#define HAL_MODULE_ENABLED
+#define HAL_ADC_MODULE_ENABLED
+#define HAL_CRC_MODULE_ENABLED
+#define HAL_DMA_MODULE_ENABLED
+#define HAL_GPIO_MODULE_ENABLED
+#define HAL_I2C_MODULE_ENABLED
+#define HAL_PWR_MODULE_ENABLED
+#define HAL_RCC_MODULE_ENABLED
+//#define HAL_RTC_MODULE_ENABLED Real Time Clock...do we use it?
+#define HAL_SPI_MODULE_ENABLED
+#define HAL_TIM_MODULE_ENABLED
+#define HAL_USART_MODULE_ENABLED
+#define HAL_CORTEX_MODULE_ENABLED
+//#define HAL_UART_MODULE_ENABLED // by default
+//#define HAL_PCD_MODULE_ENABLED  // Since STM32 v3.10700.191028 this is automatically added if any type of USB is enabled (as in Arduino IDE)
+#define HAL_WWDG_MODULE_ENABLED
+#define HAL_SD_MODULE_ENABLED
+
+//#undef HAL_SD_MODULE_ENABLED
+#undef HAL_DAC_MODULE_ENABLED
+#undef HAL_FLASH_MODULE_ENABLED
+#undef HAL_CAN_MODULE_ENABLED
+#undef HAL_CAN_LEGACY_MODULE_ENABLED
+#undef HAL_CEC_MODULE_ENABLED
+#undef HAL_CRYP_MODULE_ENABLED
+#undef HAL_DCMI_MODULE_ENABLED
+#undef HAL_DMA2D_MODULE_ENABLED
+#undef HAL_ETH_MODULE_ENABLED
+#undef HAL_NAND_MODULE_ENABLED
+#undef HAL_NOR_MODULE_ENABLED
+#undef HAL_PCCARD_MODULE_ENABLED
+#undef HAL_SRAM_MODULE_ENABLED
+#undef HAL_SDRAM_MODULE_ENABLED
+#undef HAL_HASH_MODULE_ENABLED
+#undef HAL_EXTI_MODULE_ENABLED
+#undef HAL_SMBUS_MODULE_ENABLED
+#undef HAL_I2S_MODULE_ENABLED
+#undef HAL_IWDG_MODULE_ENABLED
+#undef HAL_LTDC_MODULE_ENABLED
+#undef HAL_DSI_MODULE_ENABLED
+#undef HAL_QSPI_MODULE_ENABLED
+#undef HAL_RNG_MODULE_ENABLED
+#undef HAL_SAI_MODULE_ENABLED
+#undef HAL_IRDA_MODULE_ENABLED
+#undef HAL_SMARTCARD_MODULE_ENABLED
+#undef HAL_HCD_MODULE_ENABLED
+#undef HAL_FMPI2C_MODULE_ENABLED
+#undef HAL_SPDIFRX_MODULE_ENABLED
+#undef HAL_DFSDM_MODULE_ENABLED
+#undef HAL_LPTIM_MODULE_ENABLED
+#undef HAL_MMC_MODULE_ENABLED
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446/ldscript.ld b/CoreN2G/src/STM32F4/variants/STM32F446/ldscript.ld
new file mode 100644
index 0000000..7c06677
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446/ldscript.ld
@@ -0,0 +1,185 @@
+/*
+*****************************************************************************
+**
+
+**  File        : LinkerScript.ld
+**
+**  Abstract    : Linker script for STM32F446VETx Device with
+**                512KByte FLASH, 128KByte RAM
+**
+**                Set heap size, stack size and stack location according
+**                to application requirements.
+**
+**                Set memory bank area and size if external memory is used.
+**
+**  Target      : STMicroelectronics STM32
+**
+**
+**  Distribution: The file is distributed as is, without any warranty
+**                of any kind.
+**
+*****************************************************************************
+** @attention
+**
+** <h2><center>&copy; COPYRIGHT(c) 2014 Ac6</center></h2>
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**   1. Redistributions of source code must retain the above copyright notice,
+**      this list of conditions and the following disclaimer.
+**   2. Redistributions in binary form must reproduce the above copyright notice,
+**      this list of conditions and the following disclaimer in the documentation
+**      and/or other materials provided with the distribution.
+**   3. Neither the name of Ac6 nor the names of its contributors
+**      may be used to endorse or promote products derived from this software
+**      without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+** OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+*****************************************************************************
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+/* Highest address of the user mode stack */
+_estack = 0x2001fffc;    /* end of RAM */
+
+/* Generate a link error if heap and stack don't fit into RAM */
+_Min_Heap_Size = 0x200;;      /* required amount of heap  */
+_Min_Stack_Size = 0x400;; /* required amount of stack */
+
+/* Specify the memory areas */
+MEMORY
+{
+FLASH (rx)      : ORIGIN = 0x8008000, LENGTH = 512K - 32K
+RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 128K
+}
+
+/* Define output sections */
+SECTIONS
+{
+  /* The startup code goes first into FLASH */
+  .isr_vector :
+  {
+    . = ALIGN(4);
+    KEEP(*(.isr_vector)) /* Startup code */
+    . = ALIGN(4);
+  } >FLASH
+
+  /* The program code and other data goes into FLASH */
+  .text ALIGN(4):
+  {
+    . = ALIGN(4);
+    __etext_start = .;
+    *(.text)           /* .text sections (code) */
+    *(.text*)          /* .text* sections (code) */
+    *(.glue_7)         /* glue arm to thumb code */
+    *(.glue_7t)        /* glue thumb to arm code */
+    *(.eh_frame)
+
+    KEEP (*(.init))
+    KEEP (*(.fini))
+
+    . = ALIGN(4);
+    _etext = .;        /* define a global symbols at end of code */
+  } >FLASH
+
+  /* Constant data goes into FLASH */
+  .rodata ALIGN(4):
+  {
+    . = ALIGN(4);
+    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
+    . = ALIGN(4);
+  } >FLASH
+
+  .ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >FLASH
+  .ARM : {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } >FLASH
+
+  .preinit_array     :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } >FLASH
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } >FLASH
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } >FLASH
+
+  /* used by the startup to initialize data */
+  _sidata = LOADADDR(.data);
+
+  /* Initialized data sections goes into RAM, load LMA copy after code */
+  .data :
+  {
+    . = ALIGN(4);
+    _sdata = .;        /* create a global symbol at data start */
+    *(.data)           /* .data sections */
+    *(.data*)          /* .data* sections */
+
+    . = ALIGN(4);
+    _edata = .;        /* define a global symbol at data end */
+  } >RAM AT> FLASH
+
+  /* Uninitialized data section */
+  . = ALIGN(4);
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss secion */
+    _sbss = .;         /* define a global symbol at bss start */
+    __bss_start__ = _sbss;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+
+    . = ALIGN(4);
+    _ebss = .;         /* define a global symbol at bss end */
+    __bss_end__ = _ebss;
+  } >RAM
+
+  /* User_heap_stack section, used to check that there is enough RAM left */
+  ._user_heap_stack :
+  {
+    . = ALIGN(4);
+    PROVIDE ( end = . );
+    PROVIDE ( _end = . );
+    . = . + _Min_Heap_Size;
+    . = . + _Min_Stack_Size;
+    . = ALIGN(4);
+  } >RAM
+
+  /* Remove information from the standard libraries */
+  /DISCARD/ :
+  {
+    libc.a ( * )
+    libm.a ( * )
+    libgcc.a ( * )
+  }
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+}
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446/variant.cpp b/CoreN2G/src/STM32F4/variants/STM32F446/variant.cpp
new file mode 100644
index 0000000..9c80b05
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446/variant.cpp
@@ -0,0 +1,209 @@
+/*
+  Copyright (c) 2011 Arduino.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+  See the GNU Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <CoreImp.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Pin number
+const PinName digitalPin[] = {
+  PA_0,  //D0
+  PA_1,  //D1
+  PA_2,  //D2
+  PA_3,  //D3
+  PA_4,  //D4
+  PA_5,  //D5
+  PA_6,  //D6
+  PA_7,  //D7
+  PA_8,  //D8
+  PA_9,  //D9
+  PA_10, //D10
+  PA_11, //D11
+  PA_12, //D12
+  PA_13, //D13
+  PA_14, //D14
+  PA_15, //D15
+  PB_0,  //D16
+  PB_1,  //D17
+  PB_2,  //D18
+  PB_3,  //D19
+  PB_4,  //D20
+  PB_5,  //D21
+  PB_6,  //D22
+  PB_7,  //D23
+  PB_8,  //D24
+  PB_9,  //D25
+  PB_10, //D26
+  PB_12, //D28
+  PB_13, //D29
+  PB_14, //D30
+  PB_15, //D31
+  PC_0,  //D32
+  PC_1,  //D33
+  PC_2,  //D34
+  PC_3,  //D35
+  PC_4,  //D36
+  PC_5,  //D37
+  PC_6,  //D38
+  PC_7,  //D39
+  PC_8,  //D40
+  PC_9,  //D41
+  PC_10, //D42
+  PC_11, //D43
+  PC_12, //D44
+  PC_13, //D45
+  PC_14, //D46
+  PC_15, //D47
+  PD_0,  //D48
+  PD_1,  //D49
+  PD_2,  //D50
+  PD_3,  //D51
+  PD_4,  //D52
+  PD_5,  //D53
+  PD_6,  //D54
+  PD_7,  //D55
+  PD_8,  //D56
+  PD_9,  //D57
+  PD_10, //D58
+  PD_11, //D59
+  PD_12, //D60
+  PD_13, //D61
+  PD_14, //D62
+  PD_15, //D63
+  PE_0,  //D64
+  PE_1,  //D65
+  PE_2,  //D66
+  PE_3,  //D67
+  PE_4,  //D68
+  PE_5,  //D69
+  PE_6,  //D70
+  PE_7,  //D71
+  PE_8,  //D72
+  PE_9,  //D73
+  PE_10, //D74
+  PE_11, //D75
+  PE_12, //D76
+  PE_13, //D77
+  PE_14, //D78
+  PE_15, //D79
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+// ----------------------------------------------------------------------------
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+  * @brief  System Clock Configuration
+  *         The system Clock is configured as follow :
+  *            System Clock source            = PLL (HSE)
+  *            SYSCLK(Hz)                     = 180000000
+  *            HCLK(Hz)                       = 180000000
+  *            AHB Prescaler                  = 1
+  *            APB1 Prescaler                 = 4
+  *            APB2 Prescaler                 = 2
+  *            HSE Frequency(Hz)              = 12000000
+  *            PLL_M                          = 6
+  *            PLL_N                          = 180
+  *            PLL_P                          = 2
+  *            PLL_Q                          = 7
+  *            VDD(V)                         = 3.3
+  *            Main regulator output voltage  = Scale1 mode
+  *            Flash Latency(WS)              = 5
+  * @param  None
+  * @retval None
+  */
+WEAK void SystemClock_Config(void)
+{
+  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
+  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
+  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
+
+  /** Configure the main internal regulator output voltage
+  */
+  __HAL_RCC_PWR_CLK_ENABLE();
+  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
+  /** Initializes the RCC Oscillators according to the specified parameters
+  * in the RCC_OscInitTypeDef structure.
+  */
+  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
+  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
+  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
+  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
+  RCC_OscInitStruct.PLL.PLLM = 12;
+  RCC_OscInitStruct.PLL.PLLN = 360;
+  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
+  RCC_OscInitStruct.PLL.PLLQ = 7;
+  RCC_OscInitStruct.PLL.PLLR = 2;
+  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+  /** Activate the Over-Drive mode
+  */
+  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+  /** Initializes the CPU, AHB and APB buses clocks
+  */
+  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
+                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
+  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLRCLK;
+  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
+  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
+  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
+
+  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
+  PeriphClkInitStruct.PLLSAI.PLLSAIM = 6;
+  PeriphClkInitStruct.PLLSAI.PLLSAIN = 96;
+  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
+  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV4;
+  PeriphClkInitStruct.PLLSAIDivQ = 1;
+  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48CLKSOURCE_PLLSAIP;
+  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+
+  /**Configure the Systick interrupt time
+  */
+  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
+
+  /**Configure the Systick
+  */
+  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
+
+  /* SysTick_IRQn interrupt configuration */
+  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
+  
+}
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446/variant.h b/CoreN2G/src/STM32F4/variants/STM32F446/variant.h
new file mode 100644
index 0000000..caffbac
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446/variant.h
@@ -0,0 +1,134 @@
+/*
+  Copyright (c) 2011 Arduino.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+  See the GNU Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#pragma once
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+/*----------------------------------------------------------------------------
+ *        Pins
+ *----------------------------------------------------------------------------*/
+
+#define PA0   0  //D0
+#define PA1   1  //D1
+#define PA2   2  //D2
+#define PA3   3  //D3
+#define PA4   4  //D4
+#define PA5   5  //D5
+#define PA6   6  //D6
+#define PA7   7  //D7
+#define PA8   8  //D8
+#define PA9   9  //D9
+#define PA10  10 //D10
+#define PA11  11 //D11
+#define PA12  12 //D12
+#define PA13  13 //D13
+#define PA14  14 //D14
+#define PA15  15 //D15
+#define PB0   16 //D16
+#define PB1   17 //D17
+#define PB2   18 //D18
+#define PB3   19 //D19
+#define PB4   20 //D20
+#define PB5   21 //D21
+#define PB6   22 //D22
+#define PB7   23 //D23
+#define PB8   24 //D24
+#define PB9   25 //D25
+#define PB10  26 //D26
+#define PB12  28 //D28
+#define PB13  29 //D29
+#define PB14  30 //D30
+#define PB15  31 //D31
+#define PC0   32 //D32
+#define PC1   33 //D33
+#define PC2   34 //D34
+#define PC3   35 //D35
+#define PC4   36 //D36
+#define PC5   37 //D37
+#define PC6   38 //D38
+#define PC7   39 //D39
+#define PC8   40 //D40
+#define PC9   41 //D41
+#define PC10  42 //D42
+#define PC11  43 //D43
+#define PC12  44 //D44
+#define PC13  45 //D45
+#define PC14  46 //D46
+#define PC15  47 //D47
+#define PD0   48 //D48
+#define PD1   49 //D49
+#define PD2   50 //D50
+#define PD3   51 //D51
+#define PD4   52 //D52
+#define PD5   53 //D53
+#define PD6   54 //D54
+#define PD7   55 //D55
+#define PD8   56 //D56
+#define PD9   57 //D57
+#define PD10  58 //D58
+#define PD11  59 //D59
+#define PD12  60 //D60
+#define PD13  61 //D61
+#define PD14  62 //D62
+#define PD15  63 //D63
+#define PE0   64 //D64
+#define PE1   65 //D65
+#define PE2   66 //D66
+#define PE3   67 //D67
+#define PE4   68 //D68
+#define PE5   69 //D69
+#define PE6   70 //D70
+#define PE7   71 //D71
+#define PE8   72 //D72
+#define PE9   73 //D73
+#define PE10  74 //D74
+#define PE11  75 //D75
+#define PE12  76 //D76
+#define PE13  77 //D77
+#define PE14  78 //D78
+#define PE15  79 //D79
+
+// This must be a literal with the same value as PEND
+#define NUM_DIGITAL_PINS        82
+// This must be a literal with a value less than or equal to to MAX_ANALOG_INPUTS
+#define NUM_ANALOG_INPUTS       16
+
+
+// On-board LED pin number
+#define LED_BUILTIN             PA7
+#define LED_GREEN               LED_BUILTIN
+
+
+/* HAL configuration */
+#define HSE_VALUE               12000000U
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+/*----------------------------------------------------------------------------
+ *        Arduino objects - C++ only
+ *----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+
+#endif
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/.DS_Store b/CoreN2G/src/STM32F4/variants/STM32F446_b/.DS_Store
new file mode 100644
index 0000000000000000000000000000000000000000..7068c5c65d781cd4ac5c32fed72940881e0d424f
GIT binary patch
literal 6148
zcmeHKO-sW-5S@(`T7uA{7h!)vz<&@*J$R9V;Mq12TZnCG)pPFt7=NE9ee*#v8@-B@
z8JK;$lX<)3?UKn7QJB2cmqcSC8p0W~5t<*2pR@NYv&bnh$Q(Ob(UzX6pr)7Yf&Zug
z?_G}Fs%cLZec!+Oy4h5VX0t#BACGr<@hOHL$7b|kjHUGEm}iC)u*O^kRb76#Ncd-#
zdqZ=20)J0;=<UE<Cd{{lnbWIeuF$UKv{g8D+l2Lzutq&rvQGAxFfep;1zZ7F;3yS9
z&1M_sir%^cu7E3WP=LP=5zbf|wu<uUKqFTG-~eGU^!aCzInl5*Y!&eY7L*E9YOpIt
zP&(q#@=C*2QRx)y@)2z1U^kQ?t7HBs=@d#uZ(RXbpsT=%4#!;ouYSM(cS$~S1zdrn
zQXmYbx6=t;$!crw<+#>H_&uDB^IF9N1sy5H$mLRe4i`f_atBx%wu*?r{6|1!@WvJR
HQw6>N5&Bi>

literal 0
HcmV?d00001

diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/PeripheralPins.c b/CoreN2G/src/STM32F4/variants/STM32F446_b/PeripheralPins.c
new file mode 100644
index 0000000..c76c7e8
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446_b/PeripheralPins.c
@@ -0,0 +1,387 @@
+/*
+ *******************************************************************************
+ * Copyright (c) 2019, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ * Automatically generated from STM32F407Z(E-G)Tx.xml
+ */
+#include <PeripheralPins.h>
+
+/* =====
+ * Note: Commented lines are alternative possibilities which are not used by default.
+ *       If you change them, you should know what you're doing first.
+ * =====
+ */
+
+//*** ADC ***
+
+#ifdef HAL_ADC_MODULE_ENABLED
+const PinMap PinMap_ADC[] = {
+  {PA_0,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 0, 0)}, // ADC1_IN0      E0_DIR
+  {PA_1,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // ADC1_IN1      BLTOUCH_2
+  {PA_2,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // ADC1_IN2      BLTOUCH_4
+  {PA_3,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 3, 0)}, // ADC1_IN3      E1_EN
+  {PA_4,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC1_IN4      TF_SS
+  {PA_5,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC1_IN5      TF_SCLK
+  {PA_6,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 6, 0)}, // ADC1_IN6      TF_MISO
+  {PA_7,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 7, 0)}, // ADC1_IN7      LED
+  {PB_0,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 8, 0)}, // ADC1_IN8      HEATER2
+  {PB_1,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 9, 0)}, // ADC1_IN9      HEATER0
+  {PC_0,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 10, 0)}, // ADC1_IN10    Z_EN      BED_T
+  {PC_1,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 11, 0)}, // ADC1_IN11    EXP_14    T0
+  {PC_2,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 12, 0)}, // ADC1_IN12    Z_DIR     T1  
+  {PC_3,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 13, 0)}, // ADC1_IN13    E0_EN     T2
+  {PC_4,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC1_IN14    EXP_8
+  {PC_5,  ADC1,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC1_IN15    EXP_7
+
+  #if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio, 24 ADC
+    {PF_3,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 9, 0)}, // ADC3_IN9    TH_0
+    {PF_4,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 14, 0)}, // ADC3_IN14  TH_1
+    {PF_5,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 15, 0)}, // ADC3_IN15  TH_2
+    {PF_6,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 4, 0)}, // ADC3_IN4    TH_3
+    {PF_7,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 5, 0)}, // ADC3_IN5    EXP_13
+    {PF_8,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 6, 0)}, // ADC3_IN6    EXP_3
+    {PF_9,  ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 7, 0)}, // ADC3_IN7    EXP_6
+    {PF_10, ADC3,  STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 8, 0)}, // ADC3_IN8    EXP_5
+  #endif
+  {NC,    NP,    0}
+};
+#endif
+
+//*** DAC ***
+
+#ifdef HAL_DAC_MODULE_ENABLED
+const PinMap PinMap_DAC[] = {
+  {PA_4,  DAC1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 1, 0)}, // DAC_OUT1
+  {PA_5,  DAC1, STM_PIN_DATA_EXT(STM_MODE_ANALOG, GPIO_NOPULL, 0, 2, 0)}, // DAC_OUT2
+  {NC,    NP,    0}
+};
+#endif
+
+//*** I2C ***
+
+#ifdef HAL_I2C_MODULE_ENABLED
+const PinMap PinMap_I2C_SDA[] = {
+  {PB_7,  I2C1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+  {PB_9,  I2C1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+  {PC_12, I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+  {PC_9,  I2C3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)},
+  #if STM32F4X_PIN_NUM >= 144   // 144 pins mcu, 114 gpio
+    #if STM32F4X_PIN_NUM >= 176
+      {PH_5,  I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+      {PH_8,  I2C3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)},
+    #else
+      {PF_0,  I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+    #endif
+  #endif
+  {NC,    NP,    0}
+};
+#endif
+
+#ifdef HAL_I2C_MODULE_ENABLED
+const PinMap PinMap_I2C_SCL[] = {
+  {PA_8,  I2C3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)},
+  {PB_6,  I2C1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+  {PB_8,  I2C1, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C1)},
+  {PB_10, I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+  #if STM32F4X_PIN_NUM >= 144   // 144 pins mcu, 114 gpio
+    #if STM32F4X_PIN_NUM >= 176
+      //{PF_1,  I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+      {PH_4,  I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+      {PH_7,  I2C3, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C3)},
+    #else
+      {PF_1,  I2C2, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_NOPULL, GPIO_AF4_I2C2)},
+    #endif
+  #endif
+  {NC,    NP,    0}
+};
+#endif
+
+//*** PWM ***
+// NOTE With RRF TIM1 is used for Soft UART and TIM5 is used for Stepping. So we can't use those
+#ifdef HAL_TIM_MODULE_ENABLED
+const PinMap PinMap_PWM[] = {
+  {PA_0,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)}, // TIM2_CH1
+  //{PA_0,  TIM5,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 1, 0)}, // TIM5_CH1
+  {PA_1,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 2, 0)}, // TIM2_CH2     BL-TOUCH-SERVO   H1
+  //{PA_1,  TIM5,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 2, 0)}, // TIM5_CH2
+  //{PA_1,  TIM5,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 2, 0)}, // TIM5_CH2
+  {PA_2,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 3, 0)}, // TIM2_CH3     BL-TOUCH         BED
+  //{PA_2,  TIM5,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 3, 0)}, // TIM5_CH3
+  //{PA_2,  TIM9,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM9, 1, 0)}, // TIM9_CH1
+  {PA_3,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 4, 0)}, // TIM2_CH4
+  //{PA_3,  TIM5,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 4, 0)}, // TIM5_CH4
+  //{PA_3,  TIM9,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM9, 2, 0)}, // TIM9_CH2
+  //{PA_5,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)}, // TIM2_CH1
+  {PA_5,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)}, // TIM8_CH1N
+  //{PA_6,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)}, // TIM3_CH1
+  {PA_6,  TIM13,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM13, 1, 0)}, // TIM13_CH1
+  //{PA_7,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N
+  //{PA_7,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)}, // TIM3_CH2
+  //{PA_7,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 1)}, // TIM8_CH1N
+  {PA_7,  TIM14,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM14, 1, 0)}, // TIM14_CH1
+  //{PA_8,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 0)}, // TIM1_CH1
+  //{PA_9,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 0)}, // TIM1_CH2
+  //{PA_10, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 0)}, // TIM1_CH3
+  //{PA_11, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 4, 0)}, // TIM1_CH4
+  {PA_15, TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 1, 0)}, // TIM2_CH1
+  {PB_0,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 3, 0)}, // TIM3_CH3      HEATER2         H2
+  //{PB_0,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N
+  //{PB_0,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N
+  {PB_1,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 4, 0)}, // TIM3_CH4      HEATER0
+  //{PB_1,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N
+  //{PB_1,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)}, // TIM8_CH3N
+  {PB_3,  TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 2, 0)}, // TIM2_CH2
+  {PB_4,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)}, // TIM3_CH1
+  {PB_5,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)}, // TIM3_CH2
+  {PB_6,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 1, 0)}, // TIM4_CH1
+  {PB_7,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 2, 0)}, // TIM4_CH2
+  //{PB_8,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 3, 0)}, // TIM4_CH3
+  {PB_8,  TIM10,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM10, 1, 0)}, // TIM10_CH1
+  //{PB_9,  TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 4, 0)}, // TIM4_CH4
+  {PB_9,  TIM11,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM11, 1, 0)}, // TIM11_CH1
+  {PB_10, TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 3, 0)}, // TIM2_CH3
+  {PB_11, TIM2,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM2, 4, 0)}, // TIM2_CH4                    BL-TOUCH-SERVO
+  //{PB_13, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N
+  //{PB_14, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N
+  //{PB_14, TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 1)}, // TIM8_CH2N
+  {PB_14, TIM12,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM12, 1, 0)}, // TIM12_CH1
+  //{PB_15, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N
+  {PB_15, TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 1)}, // TIM8_CH3N
+  //{PB_15, TIM12,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM12, 2, 0)}, // TIM12_CH2
+  {PC_6,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 0)}, // TIM8_CH1
+  //{PC_6,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 1, 0)}, // TIM3_CH1
+  {PC_7,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 2, 0)}, // TIM3_CH2
+  //{PC_7,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 0)}, // TIM8_CH2
+  //{PC_8,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 3, 0)}, // TIM3_CH3
+  {PC_8,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 3, 0)}, // TIM8_CH3        FAN0        F3
+  //{PC_9,  TIM3,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM3, 4, 0)}, // TIM3_CH4
+  {PC_9,  TIM8,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 4, 0)}, // TIM8_CH4        EXTENSION1-4
+  {PD_12, TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 1, 0)}, // TIM4_CH1        BED
+  //{PD_13, TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 2, 0)}, // TIM4_CH2
+  {PD_14, TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 3, 0)}, // TIM4_CH3        HEATER1
+  {PD_15, TIM4,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM4, 4, 0)}, // TIM4_CH4
+  {PE_5,  TIM9,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM9, 1, 0)}, // TIM9_CH1        FAN1        F0
+  {PE_6,  TIM9,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM9, 2, 0)}, // TIM9_CH2        FAN2        F1
+  //{PE_8,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 1)}, // TIM1_CH1N
+  //{PE_9,  TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 1, 0)}, // TIM1_CH1
+  //{PE_10, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 1)}, // TIM1_CH2N
+  //{PE_11, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 2, 0)}, // TIM1_CH2
+  //{PE_12, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 1)}, // TIM1_CH3N
+  //{PE_13, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 3, 0)}, // TIM1_CH3
+  //{PE_14, TIM1,   STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF1_TIM1, 4, 0)}, // TIM1_CH4
+  #if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+    {PF_6,  TIM10,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM10, 1, 0)}, // TIM10_CH1
+    {PF_7,  TIM11,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM11, 1, 0)}, // TIM11_CH1
+    {PF_8,  TIM13,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM13, 1, 0)}, // TIM13_CH1
+    {PF_9,  TIM14,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM14, 1, 0)}, // TIM14_CH1
+  #endif
+  #if STM32F4X_PIN_NUM >= 176  //176 pins mcu, 140 gpio
+    //{PH_10,  TIM5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 1, 0)}, // TIM5_CH1
+    {PH_6,  TIM12,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF9_TIM12, 1, 0)}, // TIM12_CH1
+    //{PH_11,  TIM5,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF2_TIM5, 2, 0)}, // TIM5_CH2
+    {PI_5,  TIM8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 1, 0)}, // TIM8_CH1
+    {PI_6,  TIM8,  STM_PIN_DATA_EXT(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF3_TIM8, 2, 0)}, // TIM8_CH2
+  #endif
+  {NC,    NP,    0}
+};
+#endif
+
+//*** SERIAL ***
+
+#ifdef HAL_UART_MODULE_ENABLED
+const PinMap PinMap_UART_TX[] = {
+  {PA_9,  USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PD_8,  USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_6,  USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  #if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+    {PG_14, USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  #endif
+  {PB_6,  USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PA_2,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {PD_5,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {PB_10, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_10, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PA_0,  UART4,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+  {PC_10, UART4,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+  {PC_12, UART5,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)},
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_UART_RX[] = {
+  {PA_10, USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PD_9,  USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_7,  USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  {PA_1,  UART4,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+  {PA_3,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  {PB_7,  USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  {PB_11, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PC_11, UART4,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART4)},
+  {PC_11, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  {PD_2,  UART5,   STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_UART5)},
+  {PD_6,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  #if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+    {PG_9,  USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  #endif
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_UART_RTS[] = {
+  //{PA_1,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  //{PA_12, USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  //{PB_14, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  //{PD_4,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  //{PD_12, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  #if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+    //{PG_8,  USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+    //{PG_12, USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  #endif
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_UART_CTS[] = {
+  //{PA_0,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  //{PA_11, USART1,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART1)},
+  //{PB_13, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  //{PD_3,  USART2,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART2)},
+  //{PD_11, USART3,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF7_USART3)},
+  #if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+    //{PG_13, USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+    //{PG_15, USART6,  STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF8_USART6)},
+  #endif
+  {NC,    NP,    0}
+};
+#endif
+
+//*** SPI ***
+
+#ifdef HAL_SPI_MODULE_ENABLED
+const PinMap PinMap_SPI_MOSI[] = {
+  {PA_7,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_5,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_5,  SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {PB_15, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_3,  SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_12, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_SPI_MISO[] = {
+  {PA_6,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_4,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_4,  SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {PB_14, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_2,  SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_11, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_SPI_SCLK[] = {
+  {PA_5,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  //{PB_3,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PB_3,  SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {PB_10, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PB_13, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PC_10, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_SPI_SSEL[] = {
+  {PA_4,  SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PA_4,  SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {PA_15, SPI1, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI1)},
+  {PC_9, SPI3, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF6_SPI3)},
+  {PB_9,  SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {PB_12, SPI2, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF5_SPI2)},
+  {NC,    NP,    0}
+};
+#endif
+
+//*** CAN ***
+
+#ifdef HAL_CAN_MODULE_ENABLED
+#error "CAN bus isn't available on this board. Driver should be disabled."
+#endif
+
+//*** ETHERNET ***
+#ifdef HAL_ETH_MODULE_ENABLED
+#error "Ethernet port isn't available on this board. Driver should be disabled."
+#endif
+
+//*** No QUADSPI ***
+
+//*** USB ***
+#ifdef HAL_PCD_MODULE_ENABLED
+const PinMap PinMap_USB_OTG_FS[] = {
+  //{PA_8,  USB_OTG_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_FS)}, // USB_OTG_FS_SOF   used by LCD
+  //{PA_9,  USB_OTG_FS, STM_PIN_DATA(STM_MODE_INPUT, GPIO_NOPULL, GPIO_AF_NONE)},     // USB_OTG_FS_VBUS  available on wifi port, if empty
+  //{PA_10, USB_OTG_FS, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_PULLUP, GPIO_AF10_OTG_FS)}, // USB_OTG_FS_ID    available on UART1_RX if not used
+  {PA_11, USB_OTG_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_FS)}, // USB_OTG_FS_DM
+  {PA_12, USB_OTG_FS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_FS)}, // USB_OTG_FS_DP
+  {NC,    NP,    0}
+};
+
+const PinMap PinMap_USB_OTG_HS[] = { /*
+  #ifdef USE_USB_HS_IN_FS
+    {PB_12, USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_OD, GPIO_PULLUP, GPIO_AF12_OTG_HS_FS)}, // USB_OTG_HS_ID
+    {PB_13, USB_OTG_HS, STM_PIN_DATA(STM_MODE_INPUT, GPIO_NOPULL, GPIO_AF_NONE)}, // USB_OTG_HS_VBUS
+    {PB_14, USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_OTG_HS_FS)}, // USB_OTG_HS_DM
+    {PB_15, USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_OTG_HS_FS)}, // USB_OTG_HS_DP
+  #else
+    #error "USB in HS mode isn't supported by the board"
+    {PA_3,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D0
+    {PB_0,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D1
+    {PB_1,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D2
+    {PB_5,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D7
+    {PB_10, USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D3
+    {PB_12, USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D5
+    {PB_13, USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_D6
+    {PC_0,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_STP
+    {PC_2,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_DIR
+    {PC_3,  USB_OTG_HS, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF10_OTG_HS)}, // USB_OTG_HS_ULPI_NXT
+  #endif // USE_USB_HS_IN_FS
+  */
+  {NC,    NP,    0}
+};
+#endif
+
+//*** SD ***
+
+#ifdef HAL_SD_MODULE_ENABLED
+WEAK const PinMap PinMap_SD[] = {
+  // {PB_8,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D4
+  // {PB_9,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D5
+  // {PC_6,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D6
+  // {PC_7,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D7
+  {PC_8,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D0
+  {PC_9,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D1
+  {PC_10, SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D2
+  {PC_11, SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_PULLUP, GPIO_AF12_SDIO)}, // SDIO_D3
+  {PC_12, SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF12_SDIO)}, // SDIO_CK
+  {PD_2,  SDIO, STM_PIN_DATA(STM_MODE_AF_PP, GPIO_NOPULL, GPIO_AF12_SDIO)}, // SDIO_CMD
+  {NC,    NP,    0}
+};
+#endif
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/PinNamesVar.h b/CoreN2G/src/STM32F4/variants/STM32F446_b/PinNamesVar.h
new file mode 100644
index 0000000..1c65f65
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446_b/PinNamesVar.h
@@ -0,0 +1,25 @@
+/* USB */
+#ifdef USBCON
+#define USB_OTG_FS_SOF       PA_8
+#define USB_OTG_FS_VBUS      PA_9
+#define USB_OTG_FS_ID        PA_10
+#define USB_OTG_FS_DM        PA_11
+#define USB_OTG_FS_DP        PA_12
+#define USB_OTG_HS_ULPI_D0   PA_3
+#define USB_OTG_HS_SOF       PA_4
+#define USB_OTG_HS_ULPI_CK   PA_5
+#define USB_OTG_HS_ULPI_D1   PB_0
+#define USB_OTG_HS_ULPI_D2   PB_1
+#define USB_OTG_HS_ULPI_D7   PB_5
+#define USB_OTG_HS_ULPI_D3   PB_10
+#define USB_OTG_HS_ULPI_D4   PB_2
+#define USB_OTG_HS_ID        PB_12
+#define USB_OTG_HS_ULPI_D5   PB_12
+#define USB_OTG_HS_ULPI_D6   PB_13
+#define USB_OTG_HS_VBUS      PB_13
+#define USB_OTG_HS_DM        PB_14
+#define USB_OTG_HS_DP        PB_15
+#define USB_OTG_HS_ULPI_STP  PC_0
+#define USB_OTG_HS_ULPI_DIR  PC_2
+#define USB_OTG_HS_ULPI_NXT  PC_3
+#endif
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/hal_conf_extra.h b/CoreN2G/src/STM32F4/variants/STM32F446_b/hal_conf_extra.h
new file mode 100644
index 0000000..318e84d
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446_b/hal_conf_extra.h
@@ -0,0 +1,53 @@
+#pragma once
+
+#define HAL_MODULE_ENABLED
+#define HAL_ADC_MODULE_ENABLED
+#define HAL_CRC_MODULE_ENABLED
+#define HAL_DMA_MODULE_ENABLED
+#define HAL_GPIO_MODULE_ENABLED
+#define HAL_I2C_MODULE_ENABLED
+#define HAL_PWR_MODULE_ENABLED
+#define HAL_RCC_MODULE_ENABLED
+//#define HAL_RTC_MODULE_ENABLED Real Time Clock...do we use it?
+#define HAL_SPI_MODULE_ENABLED
+#define HAL_TIM_MODULE_ENABLED
+#define HAL_USART_MODULE_ENABLED
+#define HAL_CORTEX_MODULE_ENABLED
+//#define HAL_UART_MODULE_ENABLED // by default
+//#define HAL_PCD_MODULE_ENABLED  // Since STM32 v3.10700.191028 this is automatically added if any type of USB is enabled (as in Arduino IDE)
+#define HAL_WWDG_MODULE_ENABLED
+#define HAL_SD_MODULE_ENABLED
+
+//#undef HAL_SD_MODULE_ENABLED
+#undef HAL_DAC_MODULE_ENABLED
+#undef HAL_FLASH_MODULE_ENABLED
+#undef HAL_CAN_MODULE_ENABLED
+#undef HAL_CAN_LEGACY_MODULE_ENABLED
+#undef HAL_CEC_MODULE_ENABLED
+#undef HAL_CRYP_MODULE_ENABLED
+#undef HAL_DCMI_MODULE_ENABLED
+#undef HAL_DMA2D_MODULE_ENABLED
+#undef HAL_ETH_MODULE_ENABLED
+#undef HAL_NAND_MODULE_ENABLED
+#undef HAL_NOR_MODULE_ENABLED
+#undef HAL_PCCARD_MODULE_ENABLED
+#undef HAL_SRAM_MODULE_ENABLED
+#undef HAL_SDRAM_MODULE_ENABLED
+#undef HAL_HASH_MODULE_ENABLED
+#undef HAL_EXTI_MODULE_ENABLED
+#undef HAL_SMBUS_MODULE_ENABLED
+#undef HAL_I2S_MODULE_ENABLED
+#undef HAL_IWDG_MODULE_ENABLED
+#undef HAL_LTDC_MODULE_ENABLED
+#undef HAL_DSI_MODULE_ENABLED
+#undef HAL_QSPI_MODULE_ENABLED
+#undef HAL_RNG_MODULE_ENABLED
+#undef HAL_SAI_MODULE_ENABLED
+#undef HAL_IRDA_MODULE_ENABLED
+#undef HAL_SMARTCARD_MODULE_ENABLED
+#undef HAL_HCD_MODULE_ENABLED
+#undef HAL_FMPI2C_MODULE_ENABLED
+#undef HAL_SPDIFRX_MODULE_ENABLED
+#undef HAL_DFSDM_MODULE_ENABLED
+#undef HAL_LPTIM_MODULE_ENABLED
+#undef HAL_MMC_MODULE_ENABLED
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/ldscript.ld b/CoreN2G/src/STM32F4/variants/STM32F446_b/ldscript.ld
new file mode 100644
index 0000000..0fc8c29
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446_b/ldscript.ld
@@ -0,0 +1,184 @@
+/*
+*****************************************************************************
+**
+
+**  File        : LinkerScript.ld
+**
+**  Abstract    : Linker script for STM32F446VETx Device with
+**                512KByte FLASH, 128KByte RAM
+**
+**                Set heap size, stack size and stack location according
+**                to application requirements.
+**
+**                Set memory bank area and size if external memory is used.
+**
+**  Target      : STMicroelectronics STM32
+**
+**
+**  Distribution: The file is distributed as is, without any warranty
+**                of any kind.
+**
+*****************************************************************************
+** @attention
+**
+** <h2><center>&copy; COPYRIGHT(c) 2014 Ac6</center></h2>
+**
+** Redistribution and use in source and binary forms, with or without modification,
+** are permitted provided that the following conditions are met:
+**   1. Redistributions of source code must retain the above copyright notice,
+**      this list of conditions and the following disclaimer.
+**   2. Redistributions in binary form must reproduce the above copyright notice,
+**      this list of conditions and the following disclaimer in the documentation
+**      and/or other materials provided with the distribution.
+**   3. Neither the name of Ac6 nor the names of its contributors
+**      may be used to endorse or promote products derived from this software
+**      without specific prior written permission.
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+** CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+** OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**
+*****************************************************************************
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+/* Highest address of the user mode stack */
+_estack = 0x2001fffc;    /* end of RAM */
+/* Generate a link error if heap and stack don't fit into RAM */
+_Min_Heap_Size = 0x200;;      /* required amount of heap  */
+_Min_Stack_Size = 0x400;; /* required amount of stack */
+
+/* Specify the memory areas */
+MEMORY
+{
+FLASH (rx)      : ORIGIN = 0x8008000, LENGTH = 512K - 32K
+RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 128K
+}
+
+/* Define output sections */
+SECTIONS
+{
+  /* The startup code goes first into FLASH */
+  .isr_vector :
+  {
+    . = ALIGN(4);
+    KEEP(*(.isr_vector)) /* Startup code */
+    . = ALIGN(4);
+  } >FLASH
+
+  /* The program code and other data goes into FLASH */
+  .text ALIGN(4):
+  {
+    . = ALIGN(4);
+    __etext_start = .;
+    *(.text)           /* .text sections (code) */
+    *(.text*)          /* .text* sections (code) */
+    *(.glue_7)         /* glue arm to thumb code */
+    *(.glue_7t)        /* glue thumb to arm code */
+    *(.eh_frame)
+
+    KEEP (*(.init))
+    KEEP (*(.fini))
+
+    . = ALIGN(4);
+    _etext = .;        /* define a global symbols at end of code */
+  } >FLASH
+
+  /* Constant data goes into FLASH */
+  .rodata ALIGN(4):
+  {
+    . = ALIGN(4);
+    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
+    . = ALIGN(4);
+  } >FLASH
+
+  .ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >FLASH
+  .ARM : {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } >FLASH
+
+  .preinit_array     :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } >FLASH
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } >FLASH
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } >FLASH
+
+  /* used by the startup to initialize data */
+  _sidata = LOADADDR(.data);
+
+  /* Initialized data sections goes into RAM, load LMA copy after code */
+  .data :
+  {
+    . = ALIGN(4);
+    _sdata = .;        /* create a global symbol at data start */
+    *(.data)           /* .data sections */
+    *(.data*)          /* .data* sections */
+
+    . = ALIGN(4);
+    _edata = .;        /* define a global symbol at data end */
+  } >RAM AT> FLASH
+
+  /* Uninitialized data section */
+  . = ALIGN(4);
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss secion */
+    _sbss = .;         /* define a global symbol at bss start */
+    __bss_start__ = _sbss;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+
+    . = ALIGN(4);
+    _ebss = .;         /* define a global symbol at bss end */
+    __bss_end__ = _ebss;
+  } >RAM
+
+  /* User_heap_stack section, used to check that there is enough RAM left */
+  ._user_heap_stack :
+  {
+    . = ALIGN(4);
+    PROVIDE ( end = . );
+    PROVIDE ( _end = . );
+    . = . + _Min_Heap_Size;
+    . = . + _Min_Stack_Size;
+    . = ALIGN(4);
+  } >RAM
+
+  /* Remove information from the standard libraries */
+  /DISCARD/ :
+  {
+    libc.a ( * )
+    libm.a ( * )
+    libgcc.a ( * )
+  }
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+}
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/variant.cpp b/CoreN2G/src/STM32F4/variants/STM32F446_b/variant.cpp
new file mode 100644
index 0000000..148030a
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446_b/variant.cpp
@@ -0,0 +1,278 @@
+/*
+ *******************************************************************************
+ * Copyright (c) 2017, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ */
+
+#include <CoreImp.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+#if 0
+// Pin number
+// This array allows to wrap Arduino pin number(Dx or x)
+// to STM32 PinName (PX_n)
+const PinName digitalPin[] = {
+#if STM32F4X_PIN_NUM >= 64  //64 pins mcu, 51 gpio
+  PC_13, //D0
+  PC_14, //D1  - OSC32_IN
+  PC_15, //D2  - OSC32_OUT
+  PH_0,  //D3  - OSC_IN
+  PH_1,  //D4  - OSC_OUT
+  PB_2,  //D5  - BOOT1
+  PB_10, //D6  - 1:SPI2_SCK / I2C2_SCL / USART3_TX / TIM2_CH3
+  // PB_11, //D7  - 1:I2C2_SDA / USART3_RX / TIM2_CH4
+  PB_12, //D8  - 1:SPI2_NSS / OTG_HS_ID
+  PB_13, //D9  - 1:SPI2_SCK  2:OTG_HS_VBUS
+  PB_14, //D10 - 1:SPI2_MISO / TIM12_CH1 / OTG_HS_DM
+  PB_15, //D11 - SPI2_MOSI / TIM12_CH2 / OTG_HS_DP
+  PC_6,  //D12 - 1:TIM8_CH1 / SDIO_D6 / USART6_TX / TIM3_CH1
+  PC_7,  //D13 - 1:TIM8_CH2 / SDIO_D7 / USART6_RX / TIM3_CH2
+  PC_8,  //D14 - 1:TIM8_CH3 / SDIO_D0 / TIM3_CH3
+  PC_9,  //D15 - 1:TIM8_CH4 / SDIO_D1 / TIM3_CH4
+  PA_8,  //D16 - 1:TIM1_CH1 / I2C3_SCL / OTG_FS_SOF
+  PA_9,  //D17 - 1:USART1_TX / TIM1_CH2  2:OTG_FS_VBUS
+  PA_10, //D18 - 1:USART1_RX / TIM1_CH3 / OTG_FS_ID
+  PA_11, //D19 - 1:TIM1_CH4 / OTG_FS_DM
+  PA_12, //D20 - 1:OTG_FS_DP
+  PA_13, //D21 - 0:JTMS-SWDIO
+  PA_14, //D22 - 0:JTCK-SWCLK
+  PA_15, //D23 - 0:JTDI  1:SPI3_NSS / SPI1_NSS
+  PC_10, //D24 - 1:UART4_TX / SPI3_SCK / SDIO_D2 / USART3_TX
+  PC_11, //D25 - 1:UART4_RX / SPI3_MISO / SDIO_D3 / USART3_RX
+  PC_12, //D26 - 1:UART5_TX / SPI3_MOSI / SDIO_CK
+  PD_2,  //D27 - 1:UART5_RX / SDIO_CMD
+  PB_3,  //D28 - 0:JTDO  1:SPI3_SCK / TIM2_CH2 / SPI1_SCK
+  PB_4,  //D29 - 0:NJTRST  1:SPI3_MISO / TIM3_CH1 / SPI1_MISO
+  PB_5,  //D30 - 1:TIM3_CH2 / SPI1_MOSI / SPI3_MOSI
+  PB_6,  //D31 - 1:I2C1_SCL / TIM4_CH1 / USART1_TX
+  PB_7,  //D32 - 1:I2C1_SDA / TIM4_CH2 / USART1_RX
+  PB_8,  //D33 - 1:I2C1_SCL / TIM4_CH3 / SDIO_D4 / TIM10_CH1
+  PB_9,  //D34 - 1:I2C1_SDA / TIM4_CH4 / SDIO_D5 / TIM11_CH1 / SPI2_NSS
+  PA_0,  //D35/A0 - 1:UART4_TX / TIM5_CH1  2:ADC123_IN0
+  PA_1,  //D36/A1 - 1:UART4_RX / TIM5_CH2 / TIM2_CH2  2:ADC123_IN1
+  PA_2,  //D37/A2 - 1:USART2_TX /TIM5_CH3 / TIM9_CH1 / TIM2_CH3  2:ADC123_IN2
+  PA_3,  //D38/A3 - 1:USART2_RX /TIM5_CH4 / TIM9_CH2 / TIM2_CH4  2:ADC123_IN3
+  PA_4,  //D39/A4 - NOT FT 1:SPI1_NSS / SPI3_NSS / USART2_CK  2:ADC12_IN4 / DAC_OUT1
+  PA_5,  //D40/A5 - NOT FT 1:SPI1_SCK  2:ADC12_IN5 / DAC_OUT2
+  PA_6,  //D41/A6 - 1:SPI1_MISO / TIM13_CH1 / TIM3_CH1  2:ADC12_IN6
+  PA_7,  //D42/A7 - 1:SPI1_MOSI / TIM14_CH1 / TIM3_CH2  2:ADC12_IN7
+  PB_0,  //D43/A8 - 1:TIM3_CH3  2:ADC12_IN8
+  PB_1,  //D44/A9 - 1:TIM3_CH4  2:ADC12_IN9
+  PC_0,  //D45/A10 - 1:  2:ADC123_IN10
+  PC_1,  //D46/A11 - 1:  2:ADC123_IN11
+  PC_2,  //D47/A12 - 1:SPI2_MISO  2:ADC123_IN12
+  PC_3,  //D48/A13 - 1:SPI2_MOSI  2:ADC123_IN13
+  PC_4,  //D49/A14 - 1:  2:ADC12_IN14
+  PC_5,  //D50/A15 - 1:  2:ADC12_IN15
+  #if STM32F4X_PIN_NUM >= 144
+   PF_3,  //D51/A16 - 1:FSMC_A3  2:ADC3_IN9
+   PF_4,  //D52/A17 - 1:FSMC_A4  2:ADC3_IN14
+   PF_5,  //D53/A18 - 1:FSMC_A5  2:ADC3_IN15
+   PF_6,  //D54/A19 - 1:TIM10_CH1  2:ADC3_IN4
+   PF_7,  //D55/A20 - 1:TIM11_CH1  2:ADC3_IN5
+   PF_8,  //D56/A21 - 1:TIM13_CH1  2:ADC3_IN6
+   PF_9,  //D57/A22 - 1;TIM14_CH1  2:ADC3_IN7
+   PF_10, //D58/A23 - 2:ADC3_IN8
+  #endif
+#endif
+#if STM32F4X_PIN_NUM >= 100  //100 pins mcu, 82 gpio
+ PE_2,  //D59 - 1:FSMC_A23
+ PE_3,  //D60 - 1:FSMC_A19
+ PE_4,  //D61 - 1:FSMC_A20
+ PE_5,  //D62 - 1:FSMC_A21
+  PE_6,  //D63 - 1:FSMC_A22
+ PE_7,  //D64 - 1:FSMC_D4
+  PE_8,  //D65 - 1:FSMC_D5
+ PE_9,  //D66 - 1:FSMC_D6 / TIM1_CH1
+ PE_10, //D67 - 1:FSMC_D7
+ PE_11, //D68 - 1:FSMC_D8 / TIM1_CH2
+ PE_12, //D69 - 1:FSMC_D9
+ PE_13, //D70 - 1:FSMC_D10 / TIM1_CH3
+ PE_14, //D71 - 1:FSMC_D11 / TIM1_CH4
+ PE_15, //D72 - 1:FSMC_D12
+ PD_8,  //D73 - 1:FSMC_D13 / USART3_TX
+ PD_9,  //D74 - 1:FSMC_D14 / USART3_RX
+  PD_10, //D75 - 1:FSMC_D15
+ PD_11, //D76 - 1:FSMC_A16
+  PD_12, //D77 - 1:FSMC_A17 / TIM4_CH1
+  PD_13, //D78 - 1:FSMC_A18 / TIM4_CH2
+  PD_14, //D79 - 1:FSMC_D0 / TIM4_CH3
+  PD_15, //D80 - 1:FSMC_D1 / TIM4_CH4
+  PD_0,  //D81 - 1:FSMC_D2
+  PD_1,  //D82 - 1:FSMC_D3
+  PD_3,  //D83 - 1:FSMC_CLK
+  PD_4,  //D84 - 1:FSMC_NOE
+  PD_5,  //D85 - 1:USART2_TX
+  PD_6,  //D86 - 1:USART2_RX
+ PD_7,  //D87
+  PE_0,  //D88
+  PE_1,  //D89
+#endif
+#if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+  PF_0,  //D90 - 1:FSMC_A0 / I2C2_SDA
+  PF_1,  //D91 - 1:FSMC_A1 / I2C2_SCL
+  PF_2,  //D92 - 1:FSMC_A2
+  PF_11, //D93
+  PF_12, //D94 - 1:FSMC_A6
+  PF_13, //D95 - 1:FSMC_A7
+  PF_14, //D96 - 1:FSMC_A8
+  PF_15, //D97 - 1:FSMC_A9
+  PG_0,  //D98 - 1:FSMC_A10
+  PG_1,  //D99 - 1:FSMC_A11
+  PG_2,  //D100 - 1:FSMC_A12
+  PG_3,  //D101 - 1:FSMC_A13
+  PG_4,  //D102 - 1:FSMC_A14
+  PG_5,  //D103 - 1:FSMC_A15
+  PG_6,  //D104
+  PG_7,  //D105
+  PG_8,  //D106
+  PG_9,  //D107 - 1:USART6_RX
+  PG_10, //D108 - 1:FSMC_NE3
+  PG_11, //D109
+  PG_12, //D110 - 1:FSMC_NE4
+  PG_13, //D111 - 1:FSMC_A24
+  PG_14, //D112 - 1:FSMC_A25 / USART6_TX
+  PG_15, //D113
+#endif
+#if STM32F4X_PIN_NUM >= 176  //176 pins mcu, 140 gpio
+  PI_8,  //D114
+  PI_9,  //D115
+  PI_10, //D116
+  PI_11, //D117
+  PH_2,  //D118
+  PH_3,  //D119
+  PH_4,  //D120 - 1:I2C2_SCL
+  PH_5,  //D121 - 1:I2C2_SDA
+  PH_6,  //D122 - 1:TIM12_CH1
+  PH_7,  //D123 - 1:I2C3_SCL
+  PH_8,  //D124 - 1:I2C3_SDA
+  PH_9,  //D125 - 1:TIM12_CH2
+  PH_10, //D126 - 1:TIM5_CH1
+  PH_11, //D127 - 1:TIM5_CH2
+  PH_12, //D128 - 1:TIM5_CH3
+  PH_13, //D129
+  PH_14, //D130
+  PH_15, //D131
+  PI_0,  //D132 - 1:TIM5_CH4 / SPI2_NSS
+  PI_1,  //D133 - 1:SPI2_SCK
+  PI_2,  //D134 - 1:TIM8_CH4 /SPI2_MISO
+  PI_3,  //D135 - 1:SPI2_MOS
+  PI_4,  //D136
+  PI_5,  //D137 - 1:TIM8_CH1
+  PI_6,  //D138 - 1:TIM8_CH2
+  PI_7,  //D139 - 1:TIM8_CH3
+#endif
+};
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+// ------------------------
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ /**
+ * @brief  System Clock Configuration
+  * @param  None
+  * @retval None
+  */
+WEAK void SystemClock_Config(void)
+{
+  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
+  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
+  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
+
+  /** Configure the main internal regulator output voltage
+  */
+  __HAL_RCC_PWR_CLK_ENABLE();
+  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
+  /** Initializes the RCC Oscillators according to the specified parameters
+  * in the RCC_OscInitTypeDef structure.
+  */
+  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
+  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
+  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
+  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
+  RCC_OscInitStruct.PLL.PLLM = 8;
+  RCC_OscInitStruct.PLL.PLLN = 360;
+  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
+  RCC_OscInitStruct.PLL.PLLQ = 7;
+  RCC_OscInitStruct.PLL.PLLR = 2;
+  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+  /** Activate the Over-Drive mode
+  */
+  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+  /** Initializes the CPU, AHB and APB buses clocks
+  */
+  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
+                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
+  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLRCLK;
+  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
+  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
+  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
+
+  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
+  PeriphClkInitStruct.PLLSAI.PLLSAIM = 6;
+  PeriphClkInitStruct.PLLSAI.PLLSAIN = 96;
+  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
+  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV4;
+  PeriphClkInitStruct.PLLSAIDivQ = 1;
+  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48CLKSOURCE_PLLSAIP;
+  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
+  {
+    _Error_Handler(__FILE__, __LINE__);
+  }
+
+    /**Configure the Systick interrupt time
+  */
+  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
+
+  /**Configure the Systick
+  */
+  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
+
+  /* SysTick_IRQn interrupt configuration */
+ HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
+}
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/CoreN2G/src/STM32F4/variants/STM32F446_b/variant.h b/CoreN2G/src/STM32F4/variants/STM32F446_b/variant.h
new file mode 100644
index 0000000..4b1c251
--- /dev/null
+++ b/CoreN2G/src/STM32F4/variants/STM32F446_b/variant.h
@@ -0,0 +1,325 @@
+/*
+ *******************************************************************************
+ * Copyright (c) 2017, STMicroelectronics
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of STMicroelectronics nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *******************************************************************************
+ */
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+/*----------------------------------------------------------------------------
+ *        Pins
+ *----------------------------------------------------------------------------*/
+
+#ifdef STM32F446xx
+  #define STM32F4X_PIN_NUM  64  //64 pins mcu, 51 gpio
+  #define STM32F4X_GPIO_NUM 51
+  #define STM32F4X_ADC_NUM  16
+#elif defined(STM32F407_5VX)
+  #define STM32F4X_PIN_NUM  100  //100 pins mcu, 82 gpio
+  #define STM32F4X_GPIO_NUM 82
+  #define STM32F4X_ADC_NUM  16
+#elif defined(STM32F407_5ZX)
+  #define STM32F4X_PIN_NUM  144  //144 pins mcu, 114 gpio
+  #define STM32F4X_GPIO_NUM 114
+  #define STM32F4X_ADC_NUM  24
+#elif defined(STM32F407IX)
+  #define STM32F4X_PIN_NUM  176  //176 pins mcu, 140 gpio
+  #define STM32F4X_GPIO_NUM 140
+  #define STM32F4X_ADC_NUM  24
+#else
+  #error "no match MCU defined"
+#endif
+#if 0
+#if STM32F4X_PIN_NUM >= 64  //64 pins mcu, 51 gpio
+  #define PC13  0
+  #define PC14  1 //OSC32_IN
+  #define PC15  2 //OSC32_OUT
+  #define PH0   3 //OSC_IN
+  #define PH1   4 //OSC_OUT
+  #define PB2   5 //BOOT1
+  #define PB10  6 //1:SPI2_SCK / I2C2_SCL / USART3_TX / TIM2_CH3
+  // #define PB11  7 //1:I2C2_SDA / USART3_RX / TIM2_CH4
+  #define PB12  8 //1:SPI2_NSS / OTG_HS_ID
+  #define PB13  9 //1:SPI2_SCK  2:OTG_HS_VBUS
+  #define PB14  10 //1:SPI2_MISO / TIM12_CH1 / OTG_HS_DM
+  #define PB15  11 //SPI2_MOSI / TIM12_CH2 / OTG_HS_DP
+  #define PC6   12 //1:TIM8_CH1 / SDIO_D6 / USART6_TX / TIM3_CH1
+  #define PC7   13 //1:TIM8_CH2 / SDIO_D7 / USART6_RX / TIM3_CH2
+  #define PC8   14 //1:TIM8_CH3 / SDIO_D0 / TIM3_CH3
+  #define PC9   15 //1:TIM8_CH4 / SDIO_D1 / TIM3_CH4
+  #define PA8   16 //1:TIM1_CH1 / I2C3_SCL / OTG_FS_SOF
+  #define PA9   17 //1:USART1_TX / TIM1_CH2  2:OTG_FS_VBUS
+  #define PA10  18 //1:USART1_RX / TIM1_CH3 / OTG_FS_ID
+  #define PA11  19 //1:TIM1_CH4 / OTG_FS_DM
+  #define PA12  20 //1:OTG_FS_DP
+  #define PA13  21 //0:JTMS-SWDIO
+  #define PA14  22 //0:JTCK-SWCLK
+  #define PA15  23 //0:JTDI  1:SPI3_NSS / SPI1_NSS
+  #define PC10  24 //1:UART4_TX / SPI3_SCK / SDIO_D2 / USART3_TX
+  #define PC11  25 //1:UART4_RX / SPI3_MISO / SDIO_D3 / USART3_RX
+  #define PC12  26 //1:UART5_TX / SPI3_MOSI / SDIO_CK
+  #define PD2   27 //1:UART5_RX / SDIO_CMD
+  #define PB3   28 //0:JTDO  1:SPI3_SCK / TIM2_CH2 / SPI1_SCK
+  #define PB4   29 //0:NJTRST  1:SPI3_MISO / TIM3_CH1 / SPI1_MISO
+  #define PB5   30 //1:TIM3_CH2 / SPI1_MOSI / SPI3_MOSI
+  #define PB6   31 //1:I2C1_SCL / TIM4_CH1 / USART1_TX
+  #define PB7   32 //1:I2C1_SDA / TIM4_CH2 / USART1_RX
+  #define PB8   33 //1:I2C1_SCL / TIM4_CH3 / SDIO_D4 / TIM10_CH1
+  #define PB9   34 //1:I2C1_SDA / TIM4_CH4 / SDIO_D5 / TIM11_CH1 / SPI2_NSS
+  #define PA0   35 //1:UART4_TX / TIM5_CH1  2:ADC123_IN0
+  #define PA1   36 //1:UART4_RX / TIM5_CH2 / TIM2_CH2  2:ADC123_IN1
+  #define PA2   37 //1:USART2_TX /TIM5_CH3 / TIM9_CH1 / TIM2_CH3  2:ADC123_IN2
+  #define PA3   38 //1:USART2_RX /TIM5_CH4 / TIM9_CH2 / TIM2_CH4  2:ADC123_IN3
+  #define PA4   39 //NOT FT 1:SPI1_NSS / SPI3_NSS / USART2_CK  2:ADC12_IN4 / DAC_OUT1
+  #define PA5   40 //NOT FT 1:SPI1_SCK  2:ADC12_IN5 / DAC_OUT2
+  #define PA6   41 //1:SPI1_MISO / TIM13_CH1 / TIM3_CH1  2:ADC12_IN6
+  #define PA7   42 //1:SPI1_MOSI / TIM14_CH1 / TIM3_CH2  2:ADC12_IN7
+  #define PB0   43 //1:TIM3_CH3  2:ADC12_IN8
+  #define PB1   44 //1:TIM3_CH4  2:ADC12_IN9
+  #define PC0   45 //1:  2:ADC123_IN10
+  #define PC1   46 //1:  2:ADC123_IN11
+  #define PC2   47 //1:SPI2_MISO  2:ADC123_IN12
+  #define PC3   48 //1:SPI2_MOSI  2:ADC123_IN13
+  #define PC4   49 //1:  2:ADC12_IN14
+  #define PC5   50 //1:  2:ADC12_IN15
+  #if STM32F4X_PIN_NUM >= 144
+    #define PF3   51 //1:FSMC_A3  2:ADC3_IN9
+    #define PF4   52 //1:FSMC_A4  2:ADC3_IN14
+    #define PF5   53 //1:FSMC_A5  2:ADC3_IN15
+    #define PF6   54 //1:TIM10_CH1  2:ADC3_IN4
+    #define PF7   55 //1:TIM11_CH1  2:ADC3_IN5
+    #define PF8   56 //1:TIM13_CH1  2:ADC3_IN6
+    #define PF9   57 //1;TIM14_CH1  2:ADC3_IN7
+    #define PF10  58 //2:ADC3_IN8
+  #endif
+#endif
+#if STM32F4X_PIN_NUM >= 100  //100 pins mcu, 82 gpio
+  #define PE2   (35+STM32F4X_ADC_NUM) //1:FSMC_A23
+  #define PE3   (36+STM32F4X_ADC_NUM) //1:FSMC_A19
+  #define PE4   (37+STM32F4X_ADC_NUM) //1:FSMC_A20
+  #define PE5   (38+STM32F4X_ADC_NUM) //1:FSMC_A21
+  #define PE6   (39+STM32F4X_ADC_NUM) //1:FSMC_A22
+  #define PE7   (40+STM32F4X_ADC_NUM) //1:FSMC_D4
+  #define PE8   (41+STM32F4X_ADC_NUM) //1:FSMC_D5
+  #define PE9   (42+STM32F4X_ADC_NUM) //1:FSMC_D6 / TIM1_CH1
+  #define PE10  (43+STM32F4X_ADC_NUM) //1:FSMC_D7
+  #define PE11  (44+STM32F4X_ADC_NUM) //1:FSMC_D8 / TIM1_CH2
+  #define PE12  (45+STM32F4X_ADC_NUM) //1:FSMC_D9
+  #define PE13  (46+STM32F4X_ADC_NUM) //1:FSMC_D10 / TIM1_CH3
+  #define PE14  (47+STM32F4X_ADC_NUM) //1:FSMC_D11 / TIM1_CH4
+  #define PE15  (48+STM32F4X_ADC_NUM) //1:FSMC_D12
+  #define PD8   (49+STM32F4X_ADC_NUM) //1:FSMC_D13 / USART3_TX
+  #define PD9   (50+STM32F4X_ADC_NUM) //1:FSMC_D14 / USART3_RX
+  #define PD10  (51+STM32F4X_ADC_NUM) //1:FSMC_D15
+  #define PD11  (52+STM32F4X_ADC_NUM) //1:FSMC_A16
+  #define PD12  (53+STM32F4X_ADC_NUM) //1:FSMC_A17 / TIM4_CH1
+  #define PD13  (54+STM32F4X_ADC_NUM) //1:FSMC_A18 / TIM4_CH2
+  #define PD14  (55+STM32F4X_ADC_NUM) //1:FSMC_D0 / TIM4_CH3
+  #define PD15  (56+STM32F4X_ADC_NUM) //1:FSMC_D1 / TIM4_CH4
+  #define PD0   (57+STM32F4X_ADC_NUM) //1:FSMC_D2
+  #define PD1   (58+STM32F4X_ADC_NUM) //1:FSMC_D3
+  #define PD3   (59+STM32F4X_ADC_NUM) //1:FSMC_CLK
+  #define PD4   (60+STM32F4X_ADC_NUM) //1:FSMC_NOE
+  #define PD5   (61+STM32F4X_ADC_NUM) //1:USART2_TX
+  #define PD6   (62+STM32F4X_ADC_NUM) //1:USART2_RX
+  #define PD7   (63+STM32F4X_ADC_NUM)
+  #define PE0   (64+STM32F4X_ADC_NUM)
+  #define PE1   (65+STM32F4X_ADC_NUM)
+#endif
+#if STM32F4X_PIN_NUM >= 144  //144 pins mcu, 114 gpio
+  #define PF0   (66+STM32F4X_ADC_NUM) //1:FSMC_A0 / I2C2_SDA
+  #define PF1   (67+STM32F4X_ADC_NUM) //1:FSMC_A1 / I2C2_SCL
+  #define PF2   (68+STM32F4X_ADC_NUM) //1:FSMC_A2
+  #define PF11  (69+STM32F4X_ADC_NUM)
+  #define PF12  (70+STM32F4X_ADC_NUM) //1:FSMC_A6
+  #define PF13  (71+STM32F4X_ADC_NUM) //1:FSMC_A7
+  #define PF14  (72+STM32F4X_ADC_NUM) //1:FSMC_A8
+  #define PF15  (73+STM32F4X_ADC_NUM) //1:FSMC_A9
+  #define PG0   (74+STM32F4X_ADC_NUM) //1:FSMC_A10
+  #define PG1   (75+STM32F4X_ADC_NUM) //1:FSMC_A11
+  #define PG2   (76+STM32F4X_ADC_NUM) //1:FSMC_A12
+  #define PG3   (77+STM32F4X_ADC_NUM) //1:FSMC_A13
+  #define PG4   (78+STM32F4X_ADC_NUM) //1:FSMC_A14
+  #define PG5   (79+STM32F4X_ADC_NUM) //1:FSMC_A15
+  #define PG6   (80+STM32F4X_ADC_NUM)
+  #define PG7   (81+STM32F4X_ADC_NUM)
+  #define PG8   (82+STM32F4X_ADC_NUM)
+  #define PG9   (83+STM32F4X_ADC_NUM) //1:USART6_RX
+  #define PG10  (84+STM32F4X_ADC_NUM) //1:FSMC_NE3
+  #define PG11  (85+STM32F4X_ADC_NUM)
+  #define PG12  (86+STM32F4X_ADC_NUM) //1:FSMC_NE4
+  #define PG13  (87+STM32F4X_ADC_NUM) //1:FSMC_A24
+  #define PG14  (88+STM32F4X_ADC_NUM) //1:FSMC_A25 / USART6_TX
+  #define PG15  (89+STM32F4X_ADC_NUM)
+#endif
+#if STM32F4X_PIN_NUM >= 176  //176 pins mcu, 140 gpio
+  #define PI8   (90+STM32F4X_ADC_NUM)
+  #define PI9   (91+STM32F4X_ADC_NUM)
+  #define PI10  (92+STM32F4X_ADC_NUM)
+  #define PI11  (93+STM32F4X_ADC_NUM)
+  #define PH2   (94+STM32F4X_ADC_NUM)
+  #define PH3   (95+STM32F4X_ADC_NUM)
+  #define PH4   (96+STM32F4X_ADC_NUM) //1:I2C2_SCL
+  #define PH5   (97+STM32F4X_ADC_NUM) //1:I2C2_SDA
+  #define PH6   (98+STM32F4X_ADC_NUM) //1:TIM12_CH1
+  #define PH7   (99+STM32F4X_ADC_NUM) //1:I2C3_SCL
+  #define PH8   (100+STM32F4X_ADC_NUM) //1:I2C3_SDA
+  #define PH9   (101+STM32F4X_ADC_NUM) //1:TIM12_CH2
+  #define PH10  (102+STM32F4X_ADC_NUM) //1:TIM5_CH1
+  #define PH11  (103+STM32F4X_ADC_NUM) //1:TIM5_CH2
+  #define PH12  (104+STM32F4X_ADC_NUM) //1:TIM5_CH3
+  #define PH13  (105+STM32F4X_ADC_NUM)
+  #define PH14  (106+STM32F4X_ADC_NUM)
+  #define PH15  (107+STM32F4X_ADC_NUM)
+  #define PI0   (108+STM32F4X_ADC_NUM) //1:TIM5_CH4 / SPI2_NSS
+  #define PI1   (109+STM32F4X_ADC_NUM) //1:SPI2_SCK
+  #define PI2   (110+STM32F4X_ADC_NUM) //1:TIM8_CH4 /SPI2_MISO
+  #define PI3   (111+STM32F4X_ADC_NUM) //1:SPI2_MOS
+  #define PI4   (112+STM32F4X_ADC_NUM)
+  #define PI5   (113+STM32F4X_ADC_NUM) //1:TIM8_CH1
+  #define PI6   (114+STM32F4X_ADC_NUM) //1:TIM8_CH2
+  #define PI7   (115+STM32F4X_ADC_NUM) //1:TIM8_CH3
+#endif
+
+#endif
+// This must be a literal
+#define NUM_DIGITAL_PINS        (STM32F4X_GPIO_NUM)
+// This must be a literal with a value less than or equal to MAX_ANALOG_INPUTS
+#define NUM_ANALOG_INPUTS       (STM32F4X_ADC_NUM)
+//#define NUM_ANALOG_FIRST        35
+
+// Below ADC, DAC and PWM definitions already done in the core
+// Could be redefined here if needed
+// ADC resolution is 12bits
+//#define ADC_RESOLUTION          12
+//#define DACC_RESOLUTION         12
+
+// PWM resolution
+/*
+ * BEWARE:
+ * Changing this value from the default (1000) will affect the PWM output value of analogWrite (to a PWM pin)
+ * Since the pin is toggled on capture, if you change the frequency of the timer you have to adapt the compare value (analogWrite thinks you did)
+ */
+//#define PWM_FREQUENCY           20000
+//The bottom values are the default and don't need to be redefined
+//#define PWM_RESOLUTION          8
+//#define PWM_MAX_DUTY_CYCLE      255
+
+// On-board LED pin number
+#define LED_BUILTIN             PA7
+#define LED_GREEN               LED_BUILTIN
+
+
+#define HSE_VALUE               12000000U
+
+// Below SPI and I2C definitions already done in the core
+// Could be redefined here if differs from the default one
+// SPI Definitions
+//#define PIN_SPI_MOSI            PB15
+//#define PIN_SPI_MISO            PB14
+//#define PIN_SPI_SCK             PB13
+//#define PIN_SPI_SS              PB12
+
+// I2C Definitions
+//#if STM32F4X_PIN_NUM >= 176
+//  #define PIN_WIRE_SDA          PH5
+//  #define PIN_WIRE_SCL          PH4
+//#else
+//  #define PIN_WIRE_SDA          PB7
+//  #define PIN_WIRE_SCL          PB6
+//#endif
+
+// Timer Definitions
+//Do not use timer used by PWM pins when possible. See PinMap_PWM in PeripheralPins.c
+//#define TIMER_TONE              TIM2
+//#define TIMER_SERVO             TIM5 // Only 1 Servo PIN on SKR-PRO, so use the same timer as defined in PeripheralPins
+//#define TIMER_SERIAL            TIM7
+
+// UART Definitions
+//#define ENABLE_HWSERIAL1        done automatically by the #define SERIAL_UART_INSTANCE below
+//#define ENABLE_HWSERIAL3
+//#define ENABLE_HWSERIAL6
+
+// Define here Serial instance number to map on Serial generic name (if not already used by SerialUSB)
+//#define SERIAL_UART_INSTANCE    1 //1 for Serial = Serial1 (USART1)
+
+// DEBUG_UART could be redefined to print on another instance than 'Serial'
+//#define DEBUG_UART              ((USART_TypeDef *) U(S)ARTX) // ex: USART3
+// DEBUG_UART baudrate, default: 9600 if not defined
+//#define DEBUG_UART_BAUDRATE     x
+// DEBUG_UART Tx pin name, default: the first one found in PinMap_UART_TX for DEBUG_UART
+//#define DEBUG_PINNAME_TX        PX_n // PinName used for TX
+
+// Default pin used for 'Serial' instance (ex: ST-Link)
+// Mandatory for Firmata
+//#define PIN_SERIAL_RX           PA10
+//#define PIN_SERIAL_TX           PA9
+
+// Optional PIN_SERIALn_RX and PIN_SERIALn_TX where 'n' is the U(S)ART number
+// Used when user instanciate a hardware Serial using its peripheral name.
+// Example: HardwareSerial mySerial(USART3);
+// will use PIN_SERIAL3_RX and PIN_SERIAL3_TX if defined.
+//#define PIN_SERIAL1_RX          PA10
+//#define PIN_SERIAL1_TX          PA9
+//#define PIN_SERIAL3_RX          PD9
+//#define PIN_SERIAL3_TX          PD8
+//#define PIN_SERIAL6_RX          PC7
+//#define PIN_SERIAL6_TX          PC6
+//#define PIN_SERIALLP1_RX        x // For LPUART1 RX
+//#define PIN_SERIALLP1_TX        x // For LPUART1 TX
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+/*----------------------------------------------------------------------------
+ *        Arduino objects - C++ only
+ *----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+// These serial port names are intended to allow libraries and architecture-neutral
+// sketches to automatically default to the correct port name for a particular type
+// of use.  For example, a GPS module would normally connect to SERIAL_PORT_HARDWARE_OPEN,
+// the first hardware serial port whose RX/TX pins are not dedicated to another use.
+//
+// SERIAL_PORT_MONITOR        Port which normally prints to the Arduino Serial Monitor
+//
+// SERIAL_PORT_USBVIRTUAL     Port which is USB virtual serial
+//
+// SERIAL_PORT_LINUXBRIDGE    Port which connects to a Linux system via Bridge library
+//
+// SERIAL_PORT_HARDWARE       Hardware serial port, physical RX & TX pins.
+//
+// SERIAL_PORT_HARDWARE_OPEN  Hardware serial ports which are open for use.  Their RX & TX
+//                            pins are NOT connected to anything by default.
+//#define SERIAL_PORT_MONITOR         Serial
+//#define SERIAL_PORT_HARDWARE        Serial1
+//#define SERIAL_PORT_HARDWARE_OPEN   Serial3
+//#define SERIAL_PORT_HARDWARE_OPEN1  Serial6
+#endif
\ No newline at end of file
-- 
2.31.1.windows.1

